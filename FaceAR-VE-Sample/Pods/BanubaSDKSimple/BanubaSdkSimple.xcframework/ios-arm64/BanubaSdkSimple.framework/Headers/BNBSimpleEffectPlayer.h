// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from effect_player.djinni

#import "BNBSimpleAnalyticsConfig.h"
#import "BNBSimpleCameraOrientation.h"
#import "BNBSimpleConsistencyMode.h"
#import "BNBSimpleEffectPlayerConfiguration.h"
#import "BNBSimpleEffectPlayerPlaybackState.h"
#import "BNBSimpleEffectStatus.h"
#import "BNBSimpleFrameData.h"
#import "BNBSimplePixelFormat.h"
#import "BNBSimplePixelRect.h"
#import "BNBSimpleProcessImageParams.h"
#import "BNBSimpleFullImageData.h"
#import <Foundation/Foundation.h>
@class BNBSimpleEffectPlayer;
@class BNBSimpleInputManager;
@protocol BNBSimpleAnalyticsListener;
@protocol BNBSimpleCameraPoiListener;
@protocol BNBSimpleEffectEventListener;
@protocol BNBSimpleErrorListener;
@protocol BNBSimpleFaceNumberListener;
@protocol BNBSimpleFrameDurationListener;
@protocol BNBSimpleHintListener;
@protocol BNBSimpleLowLightListener;


/**
 * The EffectPlayer class provides ability to play AR effects on set of images or video.
 * <h2>Lifecycle</h2>
 * In order to support an application lifecycle EffectPlayer provides  special methods
 * to control it during application states like pause or losing focus.
 * <h3>Effect playback</h3>
 * Initial playback state of newly created Effect Player instance is `active`. With playback
 * control methods described below, the player can be launched/resumed or paused. State of effect
 * player becomes stopped/inactive at the moment of surface loss or by calling the
 * EffectPlayer::playback_stop method.
 * One can use next three methods to control effect playback:
 *   </br> - `EffectPlayer.playback_play`. Switching to active state attempt. Possible from
 *   paused or stopped state and has no effect if effect playback is already active. Playback
 *   resumes from the position saved before `EffectPlayer.playbackPause` call.
 *   </br> - `EffectPlayer.playback_pause`. Suspend current playback attempt. The recognizer thread
 *   is stopped and all the video textures and audio units playback is stopped as well. Effect
 *   player doesn't react on EffectPlayer::pushFrame calls in suspended state except
 *   asynchronous-inconsistent mode.
 *   </br> - `EffectPlayer.playbackStop`. Switch to inactive state. In addition to pause clears
 *   recognizer's buffer. The next switch to active state will result in total rerun of active
 *   effect which means that it will be started from the very beginning.
 * <h2>Android usage example</h2>
 * If you want an application to be active on windowed mode and if the
 * focus is on another application you can switch EffectPlayer into active state when
 * `onStart` activity callback occurs and switch to paused when `onStop` occurs. Otherwise you
 * can suspend `EffectPlayer` on `onPause` and resume on `onResume` callback to make an
 * instance of the `EffectPlayer` inactive while activity losing focus.
 * <h2> Context/surface control</h2>
 * There are two methods that have to be used to ensure correct operating of the
 * EffectPlayer. Losing context without notifying the EffectPlayer
 * leads to application crash. Methods for context changes notification:
 *   </br> - `EffectPlayer.surfaceCreated`
 *   </br> - `EffectPlayer.surfaceDestroyed`
 */
@interface BNBSimpleEffectPlayer : NSObject

+ (nullable BNBSimpleEffectPlayer *)create:(nonnull BNBSimpleEffectPlayerConfiguration *)configuration;

/**
 * Get major version of EffectPlayer. Use this method to filter out breaking changes in
 * implementation of this class.
 * @note this is not version of SDK.
 * @see EffectPlayer.versionMinor
 */
+ (int32_t)versionMajor;

/**
 * Get minor version of EffectPlayer
 * @see EffectPlayer.versionMajor
 */
+ (int32_t)versionMinor;

/** Add callback to receive FPS information. */
- (void)addFrameDurationListener:(nullable id<BNBSimpleFrameDurationListener>)frameDurationListener;

/** Remove callback to receive FPS information. */
- (void)removeFrameDurationListener:(nullable id<BNBSimpleFrameDurationListener>)frameDurationListener;

/** Add callback to receive errors messages from Effect Player. */
- (void)addErrorListener:(nullable id<BNBSimpleErrorListener>)errorListener;

/** Remove callback to receive errors messages from Effect Player. */
- (void)removeErrorListener:(nullable id<BNBSimpleErrorListener>)errorListener;

/** Add callback to receive faces count in frame. */
- (void)addFaceNumberListener:(nullable id<BNBSimpleFaceNumberListener>)faceNumberListener;

/** Remove callback to receive faces count in frame. */
- (void)removeFaceNumberListener:(nullable id<BNBSimpleFaceNumberListener>)faceNumberListener;

/** Add callback to receive low light info */
- (void)addLowLightListener:(nullable id<BNBSimpleLowLightListener>)lowLightListener;

/** Remove callback to receive low light info */
- (void)removeLowLightListener:(nullable id<BNBSimpleLowLightListener>)lowLightListener;

/**
 * Add callback to receive center of the face in frame relative to top-left
 * corner in [0, 1] space.
 */
- (void)addCameraPoiListener:(nullable id<BNBSimpleCameraPoiListener>)cameraPoiListener;

/** Remove callback to receive center of the face in frame relative to top-left */
- (void)removeCameraPoiListener:(nullable id<BNBSimpleCameraPoiListener>)cameraPoiListener;

/**
 * Add callback to receive user-visible messages from effects.
 * You should display them on UI.
 */
- (void)addHintListener:(nullable id<BNBSimpleHintListener>)hintListener;

/** Remove callback to receive user-visible messages from effects. */
- (void)removeHintListener:(nullable id<BNBSimpleHintListener>)hintListener;

/** Add callback to receive events from effect. */
- (void)addEffectEventListener:(nullable id<BNBSimpleEffectEventListener>)effectEventListener;

/** Remove callback to receive events from effect. */
- (void)removeEffectEventListener:(nullable id<BNBSimpleEffectEventListener>)effectEventListener;

/**
 * Set input camera field of view. https://en.wikipedia.org/wiki/Field_of_view
 *
 * You should acquire this parameter from camera.
 */
- (void)setCameraFov:(double)value;

/**
 * Set OpenGL name of input camera external texture.
 * https://developer.android.com/reference/android/graphics/SurfaceTexture
 * @see setUseExtCamTex
 * @note This function is Android only.
 */
- (void)setExternalCameraTexture:(int32_t)value;

/**
 * Use external texture as input source.
 * @see setExternalCameraTexture
 * @note This function is Android only
 */
- (void)setUseExtCamTex:(BOOL)value;

/** Sets maximum allowed face results, if face tracking feature is present. */
- (void)setMaxFaces:(int32_t)maxFaces;

/**
 * Use to notify the EffectPlayer that the surface exists and effect can be played.
 * 0, 0 for width and height are valid values.
 */
- (void)surfaceCreated:(int32_t)width
                height:(int32_t)height;

/** Notify about rendering surface being resized */
- (void)surfaceChanged:(int32_t)width
                height:(int32_t)height;

/**
 * This method should be called right before an active context will become invalid.
 * Switches playback state to inactive state. If it's not done an application will be
 * crashed on next draw iteration. After losing the surface effect playback can't be
 * resumed from last position.
 */
- (void)surfaceDestroyed;

/** Changes effect player render size, should be called on render thread. */
- (void)setEffectSize:(int32_t)fxWidth
             fxHeight:(int32_t)fxHeight;

/**
 * Draw the current effect into the current OpenGL framebuffer. Uses internal frame_data
 * object obtained from latest push_frame recognition result.
 *
 * Return current frame number if drawing was performed and caller should swap buffers
 * otherwise `DRAW_SKIPPED`(-1)
 */
- (int64_t)draw;

/**
 * Draw the current effect into the current OpenGL framebuffer. Uses externally provided frameData
 * object instead of internal one obtained from latest push_frame recognition result.
 *
 * Return frame number from provided frameData if drawing was performed and caller should swap buffers
 * otherwise `DRAW_SKIPPED`(-1)
 */
- (int64_t)drawWithExternalFrameData:(nullable BNBSimpleFrameData *)frameData;

- (void)captureBlit:(int32_t)captureWidth
      captureHeight:(int32_t)captureHeight;

/**
 * Receive the last rendered frame in binary form.
 *
 * @param width width of the picture to take, must match the values passed to
 * `setEffectSize` or `create`
 * @param height
 *
 * @return RGBA data, size is `width * height * 4`
 */
- (nonnull NSData *)readPixels:(int32_t)width
                        height:(int32_t)height;

- (void)setRenderConsistencyMode:(BNBSimpleConsistencyMode)value;

/**
 * Request display of sub-area of the input image into sub-area of the output surface, with optional x,y flips
 * imageRect is fitted inside viewportRect
 * Resets transform to default if either rect has 0 dimensions
 * @param imageRect rectangle in input image coordinates(pixels) after applying input rotations and flips
 * @param viewportRect rectangle in output surface coordinates(pixels)
 */
- (void)setRenderTransform:(nonnull BNBSimplePixelRect *)imageRect
              viewportRect:(nonnull BNBSimplePixelRect *)viewportRect
                     xFlip:(BOOL)xFlip
                     yFlip:(BOOL)yFlip;

/**
 * Process image with current effect.
 * Must be called from render thread.
 * @param inputImage to avoid conversion recommended to use YUV image
 * @param outputPixelFormat to avoid conversion recommended to use RGBA
 */
- (nonnull NSData *)processImage:(nonnull BNBSimpleFullImageData *)inputImage
               outputPixelFormat:(BNBSimplePixelFormat)outputPixelFormat
                          params:(nonnull BNBSimpleProcessImageParams *)params;

/**
 * Process image with current effect.
 * Must be called from render thread.
 * NOTE: inputImage have copy overhead, preferable to use process_image method
 * @param inputImage input image with `width * height * 4` size
 * @param outputPixelFormat to avoid conversion recommended to use RGBA
 */
- (nonnull NSData *)processImageData:(nonnull NSData *)inputImage
                               width:(int32_t)width
                              height:(int32_t)height
                         orientation:(BNBSimpleCameraOrientation)orientation
                          isMirrored:(BOOL)isMirrored
                    inputPixelFormat:(BNBSimplePixelFormat)inputPixelFormat
                   outputPixelFormat:(BNBSimplePixelFormat)outputPixelFormat
                              params:(nonnull BNBSimpleProcessImageParams *)params;

/** Provide image to process and play effect on. */
- (void)pushFrame:(nonnull BNBSimpleFullImageData *)fullImage;

/** Provide image to process and play effect on. */
- (void)pushFrameWithNumber:(nonnull BNBSimpleFullImageData *)fullImage
                frameNumber:(int64_t)frameNumber;

- (void)playbackPlay;

- (void)playbackPause;

- (void)playbackStop;

- (BNBSimpleEffectPlayerPlaybackState)getPlaybackState;

/**
 * Launches async effect loading.
 *
 * Status can be obtained with `EffectPlayer.getEffectStatus`.
 * @param effectUrl Effect url. Used by `ResourceManager` to resolve absolute url if relative.
 */
- (void)loadEffect:(nonnull NSString *)effectUrl;

/** Works the same way as "load_effect"; launches empty effect loading. */
- (void)unloadEffect;

/** Forces full effect reload on the next load_effect() */
- (void)forceEffectReload;

/** The loading state to be updated it's necessary to perform `EffectPlayer.draw` calls in a loop. */
- (BNBSimpleEffectStatus)getEffectStatus;

/**
 * Adds js method call to call queue. Queue is performed during the *draw* operation.
 * If there is an effect in loading state, all calls will be performed
 * when the effect loading is finished.
 * @param methodName JS global function name. Member functions are not supported.
 * @param params Function arguments as JSON string.
 */
- (void)callJsMethod:(nonnull NSString *)methodName
              params:(nonnull NSString *)params;

/**
 * Request to start framedata capture process. Output file is in CBOR format.
 * @param folder Output folder.
 * @param filename Output filename. If the value is an empty string, filename is generated based on
 *   date and time.
 */
- (void)startFramedataCapture:(nonnull NSString *)folder
                     filename:(nullable NSString *)filename;

/** @see startFramedataCapture */
- (void)stopFramedataCapture;

/**
 * Request to start analytics capture process.
 * Analytics supports two business cases:
 *   1. Capture high resolution photo with face (bigger than 720p).
 *   2. Capture N frames with face (N is configurable, if N=0 capturer will skip this case).
 * Result is a path to CBOR file with images and face recognition results, compressed with zlib.
 * @param deviceInfo Any user specific information to attach in analytics report.
 * @param config Setup configurable properties (like frames counter and delay before capture).
 * @param listener Callback which is fired in one of two above mentioned cases.
 */
- (void)startAnalyticsCapture:(nonnull NSDictionary<NSString *, NSString *> *)deviceInfo
                       config:(nonnull BNBSimpleAnalyticsConfig *)config
                     listener:(nullable id<BNBSimpleAnalyticsListener>)listener;

- (void)stopAnalyticsCapture;

/**
 * Set effect audio volume.
 * @param volume A value in range `[0, 1]`, where `1` means maximum volume.
 */
- (void)setEffectVolume:(float)volume;

/** Get interface to control user iterations. This events will be passed to effect. */
- (nullable BNBSimpleInputManager *)getInputManager;

- (BOOL)isVoiceChangerConfigured;

/**
 * Initialize video processing. To provide frames use *process_video_frame* methods.
 * Effect audio is recorded as well and can be accessed using *process_recorded_audio*
 * and *write_recorded_audio*.
 * All processing methods should be called in render
 * thread and *push_frame* should not be called during processing.
 * @throw Exception Must be aborted with stop_video_processing()
 */
- (void)startVideoProcessing:(int64_t)screenWidth
                screenHeight:(int64_t)screenHeight
                 orientation:(BNBSimpleCameraOrientation)orientation
                 resetEffect:(BOOL)resetEffect;

/** Finish processing and return render in normal state. Should be used in render thread only. */
- (void)stopVideoProcessing:(BOOL)resetEffect;

/**
 * Provide frame to evaluate video processing. Must be used in render thread only.
 * @param inputImage Image to process.
 * @param process_image_params Processing params.
 * @param recognizerIterations Number of processing iterations. Higher number means higher processing quality, but lower speed. Must be greater than 1. Pass null value for default number.
 * @return Frame data with frame processing results.
 */
- (nullable BNBSimpleFrameData *)processVideoFrame:(nonnull BNBSimpleFullImageData *)inputImage
                                      params:(nonnull BNBSimpleProcessImageParams *)params
                        recognizerIterations:(nullable NSNumber *)recognizerIterations;

/**
 * Draw processed frame to image buffer. Must be used in render thread only.
 * @param inputFrameData FrameData to draw.
 * @param timeNs Frame position on timeline.
 * @param outputPixelFormat Output image format.
 * @return Buffer with processed image in selected format.
 */
- (nonnull NSData *)drawVideoFrame:(nullable BNBSimpleFrameData *)inputFrameData
                            timeNs:(int64_t)timeNs
                 outputPixelFormat:(BNBSimplePixelFormat)outputPixelFormat;

/** The same as *draw_video_frame* but accepts preallocated buffer to avoid recreation for every frame. */
- (nonnull NSData *)drawVideoFrameAllocated:(nullable BNBSimpleFrameData *)inputFrameData
                                     timeNs:(int64_t)timeNs
                          outputPixelFormat:(BNBSimplePixelFormat)outputPixelFormat
                            allocatedBuffer:(nonnull NSData *)allocatedBuffer;

/**
 * Process recorded voice with voice changer effects mixing with recorded sounds.
 * Copies in->out if no voice changer or effect is active.
 * Not thread-safe but can be called in any thread.
 * Recorded sounds have the same lifetime as the effect(e.g reset after load_effect, etc.).
 * @param inFilename Input filename.
 * @param outFilename Must have ".wav" extension.
 * @param mixVolume Relative volume for mixing in sounds, [0..1].
 */
- (void)processRecordedAudio:(nonnull NSString *)inFilename
                 outFilename:(nonnull NSString *)outFilename
                   mixVolume:(float)mixVolume;

/**
 * Save recorded audio.
 * @param filename ".wav" extension must be used.
 * @param lengthMs Track length. Set to '0' to use full duration.
 */
- (void)writeRecordedAudio:(nonnull NSString *)filename
                  lengthMs:(int64_t)lengthMs;

/**
 * Trigger record start events in EP and Effect.
 * If voice changer is active in the effect, pauses and records all sounds during recording
 * to be replayed by `processRecordedAudio`.
 */
- (void)onVideoRecordStart;

/** Triggers record stop events in EP and Effect. */
- (void)onVideoRecordEnd;

@end
